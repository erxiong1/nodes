/*
题意：大学实行学分制。每门课程都有一定的学分，学生只要选修了这门课并通过考核就能获得相应学分。学生最后的学分是他选修各门课的学分总和。

每个学生都要选择规定数量的课程。有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其他的一些课程基础上才能选修。例如《数据结构》必须在选修了《高级语言程序设计》后才能选修。我们称《高级语言程序设计》是《数据结构》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。为便于表述，每门课都有一个课号，课号依次为 1,2,3,?。

下面举例说明：

|课号 | 先修课号 | 学分 |
|:-: |:-: |:-:|
| 1 | 无 |1 |
| 2| 1 |1 |
|3 | 2 |3|
|4 | 无 |3|
|5 | 2 |4|

上例中课号 1 是课号 2 的先修课，即如果要先修课号 2，则课号 1 必定已被选过。同样，如果要选修课号 3 ，那么课号 1 和 课号 2 都一定被选修过。

学生不可能学完大学开设的所有课程，因此必须在入学时选定自己要学的课程。每个学生可选课程的总数是给定的。请找出一种选课方案使得你能得到的学分最多，并满足先修课优先的原则。假定课程间不存在时间上的冲突。
题解：典型的有依赖背包问题!!!
只要以先修课为父节点 建立树 然后因为没有先修课的 输入是0 
那么将0作为结点 并且作为根就行了
然后设置状态dp[i][j]为以i为根的选择j门课 的最大学分
然后父亲由儿子的状态凑出来 对于父亲 可以选这每个儿子的任意状态(包括不选)
那么 这就是典型分组背包了 但是前提有 根必选 因为根是所有儿子先修课 
*/ 
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int maxn=5005;
struct node{
	int x;//x为子节点 
	int next;
}a[maxn];

int head[maxn],dp[maxn][maxn];
int val[maxn];
int idx,n,m;

void add(int x,int y)
{
	a[idx].x=y;//记录这个点 
	a[idx].next=head[x];
	head[x]=idx++;
}

void dfs(int u)
{
	for(int i=head[u];~i;i=a[i].next){
		int son=a[i].x;
		dfs(son);
		for(int j=m;j>=1;j--){//j表示选几门课 因为有0这个根，所以总共可选课程数为m+1，
							//但是这里考虑的都是不带当前结点的，所以得预留一个位置来放当前根 
			for(int k=0;k<=j;k++){//k表示从以u为根的树中选几个 
				dp[u][j]=max(dp[u][j],dp[u][k]+dp[son][j-k]);
			}
		}
	}
	for(int i=m+1;i>=1;i--){//将当前根放入 
		dp[u][i]=dp[u][i-1]+val[u];
	}
	dp[u][0]=0;
}
int main()
{
	cin>>n>>m;
	memset(head,-1,sizeof head);
	for(int i=1;i<=n;i++){
		int x;
		cin>>x>>val[i];
		add(x,i);
	}
	dfs(0);
	cout<<dp[0][m+1]<<endl;
	return 0;
}
